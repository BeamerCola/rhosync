SugarAccounts:
  id: 1
  name: SugarAccounts
  url: http://rhomobile.com/sugar/soap.php?wsdl
  login: admin
  password: acc3ss$ugar
  prolog: |
    u = @source.login
    p = Digest::MD5.hexdigest(@source.password)
    ua = {'user_name' => u,'password' => p}
    ss = client.login(ua,nil)
    if ss.error.number.to_i != 0
      p 'failed to login - #{ss.error.description}'
      return
    else
      session_id = ss['id']
      uid = client.get_user_id(session_id)
    end

  call: |
    module_name = 'Accounts'
    query = '' # gets all the acounts, you can also use SQL like 'accounts.name like '%company%''
    order_by = '' # in default order. you can also use SQL like 'accounts.name'
    offset = 0 
    select_fields = ['name','industry'] # this can't be an empty array
    max_results = '10000' # if set to 0 or '', this doesn't return all the results
    deleted = 0 # whether you want to retrieve deleted records, too
    result = client.get_entry_list(session_id,module_name,query,order_by,offset,select_fields,max_results,deleted);

  sync: |
    result.entry_list.each do |x|
      x.name_value_list.each do |y|
        o=ObjectValue.new
        o.source_id=@source.id
        o.object=x['id']
        o.attrib=y.name
        o.value=y.value
        o.update_type='query'
        o.save
      end
    end

  createcall:
    # name_value_list is passed in and can be used in the code below
    # for creates we just assume that the primary keys (if fields) are left out
    result=client.set_entry(session_id,'Accounts',name_value_list);
    p result.inspect.to_s

  updatecall:
    # name_value_list is passed in and can be used in the code below
    result=client.set_entry(session_id,'Accounts',name_value_list);
    p result.inspect.to_s

  deletecall:
    name_value_list.push({'name'=>'deleted','value'=>'1'});
    result=client.set_entry(session_id,'Accounts',name_value_list);
    p result.inspect.to_s

  epilog:
    client.logout(session_id)


SugarCases:
  id: 2
  name: SugarCases
  url: http://rhomobile.com/sugar/soap.php?wsdl
  login: adam
  password: password
  prolog: |
    u = @source.login
    p = Digest::MD5.hexdigest(@source.password)
    ua = {'user_name' => u,'password' => p}
    ss = client.login(ua,nil)
    if ss.error.number.to_i != 0
      p 'failed to login - #{ss.error.description}'
      return
    else
      session_id = ss['id']
      uid = client.get_user_id(session_id)
    end

  call: |
    select_fields = ['name','case_number','priority','status','type','description','resolution'] 
    result = client.get_entry_list(session_id,'Cases','','case_number',0,select_fields,'10000',0);


  sync: |
    result.entry_list.each do |x|
      x.name_value_list.each do |y|
        o=ObjectValue.new
        o.source_id=@source.id
        o.object=x['id']
        o.attrib=y.name
        o.value=y.value
        o.update_type='query'
        o.save
      end

      # add fields that didn't come back originally!: the assigned_to and account_id
      entry_result=client.get_entry(session_id,'Cases',x['id'],['assigned_user_id','account_id'])
      entry_result.entry_list[0].name_value_list.each do |y|
        o=ObjectValue.new
        o.source_id=@source.id
        o.object=x['id']
        o.attrib=y.name
        o.value=y.value
        o.update_type='query'
        o.save
      end
    end

  createcall:
    # name_value_list is passed in and can be used in the code below
    # for creates we just assume that the primary keys (if fields) are left out
    result=client.set_entry(session_id,'Cases',name_value_list);
    p result.inspect.to_s

  updatecall:
    # name_value_list is passed in and can be used in the code below
    result=client.set_entry(session_id,'Cases',name_value_list);
    p result.inspect.to_s

  deletecall:
    name_value_list.push({'name'=>'deleted','value'=>'1'});
    result=client.set_entry(session_id,'Cases',name_value_list);
    p result.inspect.to_s

  epilog:
    client.logout(session_id)

SugarEmployees:
  id: 3
  name: SugarEmployees
  url: http://rhomobile.com/sugar/soap.php?wsdl
  login: adam
  password: password
  prolog: |
    u = @source.login
    p = Digest::MD5.hexdigest(@source.password)
    ua = {'user_name' => u,'password' => p}
    ss = client.login(ua,nil)
    if ss.error.number.to_i != 0
      p 'failed to login - #{ss.error.description}'
      return
    else
      session_id = ss['id']
      uid = client.get_user_id(session_id)
    end

  call: |
    select_fields = ['first_name','last_name','status','title','phone_mobile','user_name']
    result = client.get_entry_list(session_id,'Employees',"(users.status='Active')",'last_name',0,select_fields,'10000',0);


  sync: |
    result.entry_list.each do |x|
      x.name_value_list.each do |y|
        o=ObjectValue.new
        o.source_id=@source.id
        o.object=x['id']
        o.attrib=y.name
        o.value=y.value
        o.update_type='query'
        o.save
      end
    end

  createcall:
    # name_value_list is passed in and can be used in the code below
    # for creates we just assume that the primary keys (if fields) are left out
    result=client.set_entry(session_id,'Employees',name_value_list);
    p result.inspect.to_s

  updatecall:
    # name_value_list is passed in and can be used in the code below
    result=client.set_entry(session_id,'Employees',name_value_list);
    p result.inspect.to_s

  deletecall:
    name_value_list.push({'name'=>'deleted','value'=>'1'});
    result=client.set_entry(session_id,'Employees',name_value_list);
    p result.inspect.to_s

  epilog:
    client.logout(session_id)

SalesforceAccounts:
  id: 4
  url: http://localhost:3000/sf.wsdl
  name: SalesForceAccounts
  login: adam@rhomobile.com
  password: ac
  prolog: |
    class Account < ActiveRecord::Base
      establish_connection(:url=>'https://www.salesforce.com',
        :adapter => 'activesalesforce',
        :username => @source.login,
        :password => @source.password)
    end

  call: |
    accounts=Account.find :all

  sync:
    accounts.each do |x|
      name_value_list.each do |y|
        o=ObjectValue.new
        o.source_id=@source.id
        o.object=x['id']
        o.attrib=y.name
        o.value=y.value
        o.update_type='query'
        o.save
      end
    end


  createcall:

  updatecall:

  deletecall:

SiebelServiceRequests:
  id: 5
  name: SiebelServiceRequests
  url: secure-ausomxbha.crmondemand.com
  login: RHOMOBILE/ADAM@RHOMOBILE.COM
  password: password1
  prolog: |-
    https = Net::HTTP.new(@source.url,"443")
    https.use_ssl = true
    https.verify_mode = OpenSSL::SSL::VERIFY_NONE
    headers={"UserName"=>@source.login,"Password"=>@source.password}
    session_id=nil
    https.start do |https|
        req = Net::HTTP::Get.new("/Services/Integration?command=login", headers)
        response = https.request(req)
        resp = response.body
        p "Response " + resp
        session_id=response['Set-Cookie']
    end
    p "Session is: " + session_id.to_s
    http=nil
    binding

  call: |-
    session=session_id.to_s
    start=session.index('=')
    finish=session.index(';')
    session=session[start+1...finish] if start and finish
    endpoint_url ='https://secure-ausomxbha.crmondemand.com/Services/Integration/ServiceRequest;jsessionid='+session
    obj = Default_Binding_ServiceRequest.new(endpoint_url)
    obj.wiredump_dev = STDERR
    input=ServiceRequestWS_ServiceRequestQueryPage_Input.new
    input.startRowNum=0
    s=ServiceRequest.new
    s.serviceRequestId=""
    s.subject=""
    input.listOfServiceRequest=[s]
    output=obj.serviceRequestQueryPage(input)
    binding

  sync: |-
    output.listOfServiceRequest.each do |x|
      o=ObjectValue.new
      o.source_id=@source.id
      o.object=x.serviceRequestId
      o.attrib="subject"
      o.value=x.subject
      o.update_type="query"
      o.save
    end

  createcall:

  deletecall:



  updatecall:

  epilog:

